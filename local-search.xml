<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2024/07/12/test/"/>
    <url>/2024/07/12/test/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浏览器插件入门</title>
    <link href="/2024/06/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E5%85%A5%E9%97%A8/"/>
    <url>/2024/06/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1>浏览器插件</h1><p>开源之夏有点被导师pua到了 所以准备换了个项目 还是一个社区的项目</p><p>这个项目主要是对浏览器插件优化</p><h2 id="浏览器插件基本项目结构">浏览器插件基本项目结构</h2><p>先看看基本结构吧  基本上都会有一个<code>mainfest.json</code> 跟<code>package.json</code>基本上我感觉是一样的作用</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// 插件名称</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Hello Extensions&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// 插件的描述</span><br>    <span class="hljs-attr">&quot;description&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Base Level Extension&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// 插件的版本</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// 配置插件程序的版本号，主流版本是2，最新是3</span><br>    <span class="hljs-attr">&quot;manifest_version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><p>我们经常会点击右上角插件图标时弹出一个小窗口的页面，焦点离开时就关闭了，一般做一些临时性的交互操作；在配置文件中新增<code>browser_action</code>字段，配置popup弹框：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Hello Extensions&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;description&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Base Level Extension&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;manifest_version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// 新增popup弹框</span><br>    <span class="hljs-attr">&quot;browser_action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;default_popup&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;popup.html&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;default_icon&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;popup.png&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>然后创建我们的弹框页面panel.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">html复制代码<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello Extensions<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>点击图标后，插件显示panel.html</p><h2 id="后台background">后台background</h2><p>们也发现了，popup页面只能做临时性的交互操作，用完就关了，不能存储信息或者和其他标签页进行交互等等；这时就需要用到background（后台），它是一个常驻的页面，它的生命周期是插件中所有类型页面中最长的；它随着浏览器的打开而打开，随着浏览器的关闭而关闭，所以通常把需要一直运行的、启动就运行的、全局的代码放在background里面。</p><p>在<code>mainfest.json</code>添加路径</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;background&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;script&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;background.js&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;persistent&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>这样基本上结构就差不多了</p><h2 id="实现查看组件属性和查看状态管理状态的功能">实现查看组件属性和查看状态管理状态的功能</h2><p>这个就是开源之夏的第一个任务喽</p><p>感觉就是React的那个插件的功能</p><p>我去看了看react的源码</p><p>感觉操作就是需要先获取到组件的状态 然后看状态管理器的状态</p><p>然后监听后台管理器的消息 然后在显示的html中加上显示的部分</p><p>在content-Script中新增⼀个stateManager.ts⽂件 以便捕获和发送组件状态和状态管理器信息</p><p>哦这里补充一下 一般会有一个content-script文件夹</p><p>官方定义是</p><p>content-scripts（内容脚本）是在网页上下文中运行的文件。通过使用标准的文档对象模型(DOM)，它能够读取浏览器访问的网页的详细信息，对其进行更改，并将信息传递给其父级插件。内容脚本相对于background还是有一些访问API上的限制，它可以直接访问以下chrome的API：</p><ul><li>i18n</li><li>storage</li><li>runtime:<ul><li>connect</li><li>getManifest</li><li>getURL</li><li>id</li><li>onConnect</li><li>onMessage</li><li>sendMessage</li></ul></li></ul><p>我的理解就是监听监听监听 传信号信号信号 💬</p><p>基本上用的都是chrome的<code>api</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> mockComponentState = &#123; <span class="hljs-attr">exampleComponent</span>: &#123; <span class="hljs-attr">state</span>: <span class="hljs-string">&#x27;active&#x27;</span> &#125; &#125;;<br><span class="hljs-keyword">let</span> mockStateManagerInfo = &#123; <span class="hljs-attr">exampleStateManager</span>: &#123; <span class="hljs-attr">state</span>: <span class="hljs-string">&#x27;initialized&#x27;</span> &#125; &#125;;<br> chrome.<span class="hljs-property">runtime</span>.<span class="hljs-title function_">sendMessage</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;updateComponentState&#x27;</span>, <span class="hljs-attr">state</span>: <br>mockComponentState &#125;);<br> chrome.<span class="hljs-property">runtime</span>.<span class="hljs-title function_">sendMessage</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;updateStateManagerInfo&#x27;</span>, <span class="hljs-attr">stateManager</span>: <br>mockStateManagerInfo &#125;);<br><span class="hljs-comment">//钩子到框架特定的 API 获取真实的组件状态和状态管理器信息</span><br>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br> <span class="hljs-keyword">const</span> originalSetState = <span class="hljs-title class_">YourFramework</span>.<span class="hljs-property">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setState</span>;<br> <span class="hljs-title class_">YourFramework</span>.<span class="hljs-property">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setState</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">newState, callback</span>) &#123;<br> chrome.<span class="hljs-property">runtime</span>.<span class="hljs-title function_">sendMessage</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;updateComponentState&#x27;</span>, <span class="hljs-attr">state</span>: <br><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> &#125;);<br> <span class="hljs-keyword">return</span> originalSetState.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br> &#125;;<br> &#125;)();<br> (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br> <span class="hljs-keyword">const</span> originalDispatch = <span class="hljs-title class_">YourFramework</span>.<span class="hljs-property">store</span>.<span class="hljs-property">dispatch</span>;<br> <span class="hljs-title class_">YourFramework</span>.<span class="hljs-property">store</span>.<span class="hljs-property">dispatch</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">action</span>) &#123;<br> chrome.<span class="hljs-property">runtime</span>.<span class="hljs-title function_">sendMessage</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;updateStateManagerInfo&#x27;</span>, <span class="hljs-attr">stateManager</span>: <br><span class="hljs-title class_">YourFramework</span>.<span class="hljs-property">store</span>.<span class="hljs-title function_">getState</span>() &#125;);<br> <span class="hljs-keyword">return</span> originalDispatch.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br> &#125;;<br> &#125;)();<br></code></pre></td></tr></table></figure><p><code>chrome.runtime.sendMessage</code> 是 Chrome 扩展程序中的一种方法，用于从扩展程序中的一个部分向另一个部分发送消息，例如从内容脚本向后台脚本发送消息。</p><h3 id="用法">用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">chrome.<span class="hljs-property">runtime</span>.<span class="hljs-title function_">sendMessage</span>(extensionId, message, options, responseCallback);<br></code></pre></td></tr></table></figure><ul><li><code>extensionId</code>（可选）：字符串类型。指定接收消息的扩展程序的ID。如果消息是发送到本扩展程序，可以省略此参数。</li><li><code>message</code>：任意类型。发送的消息内容，可以是任何JSON序列化类型的数据。</li><li><code>options</code>（可选）：对象类型。包含额外的选项，比如 <code>includeTlsChannelId</code>（布尔值）。</li><li><code>responseCallback</code>（可选）：函数类型。一个函数，当收到响应消息时调用，传入一个参数 <code>response</code>，该参数是响应的消息。</li></ul><p>然后在content-Script的<code>index.ts</code>中引入使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"> <span class="hljs-comment">//监听来自 background 的消息</span><br>chrome.<span class="hljs-property">runtime</span>.<span class="hljs-property">onMessage</span>.<span class="hljs-title function_">addListener</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">message, sender, sendResponse</span>) &#123;<br>   <span class="hljs-comment">//该方法可以监听页面 contentScript 和插件的消息</span><br>  <span class="hljs-comment">// 没有 tab 信息说明消息来自插件</span><br>  <span class="hljs-keyword">if</span> (!sender.<span class="hljs-property">tab</span>  <span class="hljs-title function_">checkMessage</span>(message, <span class="hljs-title class_">DevToolBackground</span>)) &#123;<br>    <span class="hljs-title function_">changeSource</span>(message, <span class="hljs-title class_">DevToolContentScript</span>);<br>    <span class="hljs-comment">// 传递消息给页面</span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">postMessage</span>(message, <span class="hljs-string">&#x27;*&#x27;</span>);<br>  &#125;<br>  <span class="hljs-title function_">sendResponse</span>(&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;ok&#x27;</span> &#125;);<br> &#125;);<br></code></pre></td></tr></table></figure><p>他自己写的源码中有个什么window对象不能直接通过 contentScript 代码修改，只能通过添加 js 代码往页面  window 注入 hook 这玩意还没看懂 等要是选上慢慢来吧</p>]]></content>
    
    
    <categories>
      
      <category>浏览器插件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>blog</title>
    <link href="/2024/05/12/blog/"/>
    <url>/2024/05/12/blog/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Typescript-declare</title>
    <link href="/2024/05/12/Typescript-declare/"/>
    <url>/2024/05/12/Typescript-declare/</url>
    
    <content type="html"><![CDATA[<h1>declare 关键字</h1><p>最近在做那个开源之夏 然后要用到这个declare 进行类型检查就正好写一篇啦 (其实还有很多不会的)👼</p><p>本来想写<code>JSX</code>的自定义接口来着 但是没准备看懂 所以写了这个</p><h2 id="简介">简介</h2><p>declare 关键字用来告诉编译器，某个类型是存在的，可以在当前文件中使用🛩️</p><p>它的主要作用，就是让当前文件可以使用其他文件声明的类型。举例来说，自己的脚本使用外部库定义的函数，编译器会因为不知道外部函数的类型定义而报错，这时就可以在自己的脚本里面使用<code>declare</code>关键字，告诉编译器外部函数的类型。这样的话，编译单个脚本就不会因为使用了外部类型而报错。</p><p>declare 关键字可以描述以下类型。</p><ul><li>变量（const、let、var 命令声明）</li><li>type 或者 interface 命令声明的类型</li><li>class</li><li>enum</li><li>函数（function）</li><li>模块（module）</li><li>命名空间（namespace）</li></ul><p>declare 关键字的重要特点是，它只是通知编译器某个类型是存在的，不用给出具体实现。比如，只描述函数的类型，不给出函数的实现，如果不使用<code>declare</code>，这是做不到的。</p><p>declare 只能用来描述已经存在的变量和数据结构，不能用来声明新的变量和数据结构。另外，所有 declare 语句都不会出现在编译后的文件里面。</p><h2 id="declare-variable">declare variable</h2><p>declare 关键字可以给出外部变量的类型描述。</p><p>举例来说，当前脚本使用了其他脚本定义的全局变量<code>x</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript">x = <span class="hljs-number">123</span>; <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p>上面示例中，变量<code>x</code>是其他脚本定义的，当前脚本不知道它的类型，编译器就会报错。</p><p>这时使用 declare 命令给出它的类型，就不会报错了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>;x = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>如果 declare 关键字没有给出变量的具体类型，那么变量类型就是<code>any</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> x;x = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>上面示例中，变量<code>x</code>的类型为<code>any</code>。</p><p>下面的例子是脚本使用浏览器全局对象<code>document</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> <span class="hljs-variable language_">document</span>;<span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br></code></pre></td></tr></table></figure><p>上面示例中，declare 告诉编译器，变量<code>document</code>的类型是外部定义的（具体定义在 TypeScript 内置文件<code>lib.d.ts</code>）。</p><p>如果 TypeScript 没有找到<code>document</code>的外部定义，这里就会假定它的类型是<code>any</code>。</p><p>注意，declare 关键字只用来给出类型描述，是纯的类型代码，不允许设置变量的初始值，即不能涉及值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 报错 </span><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>上面示例中，declare 设置了变量的初始值，结果就报错了。</p><h2 id="declare-function">declare function</h2><p>declare 关键字可以给出外部函数的类型描述。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params">name:<span class="hljs-built_in">string</span></span>):<span class="hljs-built_in">void</span>;<br><span class="hljs-title function_">sayHello</span>(<span class="hljs-string">&#x27;zzx&#x27;</span>);<br></code></pre></td></tr></table></figure><p>上面示例中，declare 命令给出了<code>sayHello()</code>的类型描述，因此可以直接使用它。</p><p>注意，这种单独的函数类型声明语句，只能用于<code>declare</code>命令后面。一方面，TypeScript 不支持单独的函数类型声明语句；另一方面，declare 关键字后面也不能带有函数的具体实现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 报错 </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params">  name:<span class="hljs-built_in">string</span></span>):<span class="hljs-built_in">void</span>;<span class="hljs-keyword">function</span> <span class="hljs-title function_">sayHello</span>(<span class="hljs-params">name</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;你好，&#x27;</span> + name;&#125;<br></code></pre></td></tr></table></figure><p>上面示例中，单独写函数的类型声明就会报错。</p><h2 id="declare-class">declare class</h2><p>declare 给出 class 的描述描述写法如下。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name:<span class="hljs-built_in">string</span></span>);  <span class="hljs-title function_">eat</span>():<span class="hljs-built_in">void</span>;  <span class="hljs-title function_">sleep</span>():<span class="hljs-built_in">void</span>;&#125;<br></code></pre></td></tr></table></figure><p>下面是一个复杂一点的例子。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;  <br>    <span class="hljs-comment">// 静态成员  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">s0</span>():<span class="hljs-built_in">string</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-attr">s1</span>:<span class="hljs-built_in">string</span>;  <br>    <span class="hljs-comment">// 属性  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-attr">a</span>:<span class="hljs-built_in">number</span>;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">b</span>:<span class="hljs-built_in">number</span>;  <br>    <span class="hljs-comment">// 构造函数  </span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">arg:<span class="hljs-built_in">number</span></span>);  <br>    <span class="hljs-comment">// 方法  </span><br>    <span class="hljs-title function_">m</span>(<span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>):<span class="hljs-built_in">number</span>;  <br>    <span class="hljs-comment">// 存取器  </span><br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">c</span>():<span class="hljs-built_in">number</span>;  <span class="hljs-keyword">set</span> <span class="hljs-title function_">c</span>(<span class="hljs-params">value:<span class="hljs-built_in">number</span></span>);  <br>    <span class="hljs-comment">// 索引签名  </span><br>    [<span class="hljs-attr">index</span>:<span class="hljs-built_in">string</span>]:<span class="hljs-built_in">any</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，declare 后面不能给出 Class 的具体实现或初始值。</p><h2 id="declare-module，declare-namespace">declare module，declare namespace</h2><p>如果想把变量、函数、类组织在一起，可以将 declare 与 module 或 namespace 一起使用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title class_">AnimalLib</span> &#123;  <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;    <br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name:<span class="hljs-built_in">string</span></span>);   <br>    <span class="hljs-title function_">eat</span>():<span class="hljs-built_in">void</span>;    <br>    <span class="hljs-title function_">sleep</span>():<span class="hljs-built_in">void</span>;  &#125;  <br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Animals</span> = <span class="hljs-string">&#x27;Fish&#x27;</span> | <span class="hljs-string">&#x27;Dog&#x27;</span>;&#125;<br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-title class_">AnimalLib</span> <br>&#123;  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> <br>&#123;    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name:<span class="hljs-built_in">string</span></span>);    <br>      <span class="hljs-title function_">eat</span>(): <span class="hljs-built_in">void</span>;    <br>      <span class="hljs-title function_">sleep</span>(): <span class="hljs-built_in">void</span>;  <br>    &#125;  <br> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Animals</span> = <span class="hljs-string">&#x27;Fish&#x27;</span> | <span class="hljs-string">&#x27;Dog&#x27;</span>;&#125;<br></code></pre></td></tr></table></figure><p>这个栗子中 declare 关键字给出了 module 或 namespace 的类型描述。</p><p>declare module 和 declare namespace 里面，加不加 export 关键字都可以。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title class_">Foo</span> &#123;  <span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">boolean</span>;&#125;<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;io&#x27;</span> &#123; <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">readFile</span>(<span class="hljs-params">filename:<span class="hljs-built_in">string</span></span>):<span class="hljs-built_in">string</span>;&#125;<br></code></pre></td></tr></table></figure><p>上面示例中，namespace 和 module 里面使用了 export 关键字。</p><p>declare 关键字的另一个用途，是为外部模块添加属性和方法时，给出新增部分的类型描述。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Foo</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Bar</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;moduleA&#x27;</span>;<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;moduleA&#x27;</span> &#123;  <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Bar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Foo</span> &#123;    <span class="hljs-attr">custom</span>: &#123;      <span class="hljs-attr">prop1</span>:<span class="hljs-built_in">string</span>;    &#125;  &#125;&#125;<br></code></pre></td></tr></table></figure><p>上面示例中，从模块<code>moduleA</code>导入了<code>Foo</code>接口，将其重命名为<code>Bar</code>，并用 declare 关键字为<code>Bar</code>增加一个属性<code>custom</code>。</p><p>下面是另一个例子。一个项目有多个模块，可以在一个模型中，对另一个模块的接口进行类型扩展。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// a.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> A &#123;  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;&#125;<br><span class="hljs-comment">// b.ts</span><br><span class="hljs-keyword">import</span> &#123; A &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./a&#x27;</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;./a&#x27;</span> &#123;  <br>    <span class="hljs-keyword">interface</span> A &#123;    <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;  &#125;&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>:A = &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> &#125;;<br></code></pre></td></tr></table></figure><p>上面示例中，脚本<code>a.ts</code>定义了一个接口<code>A</code>，脚本<code>b.ts</code>为这个接口添加了属性<code>y</code>。<code>declare module './a' &#123;&#125;</code>表示对<code>a.ts</code>里面的模块，进行类型声明，而同名 interface 会自动合并，所以等同于扩展类型。</p><p>使用这种语法进行模块的类型扩展时，有两点需要注意：</p><p>（1）<code>declare module NAME</code>语法里面的模块名<code>NAME</code>，跟 import 和 export 的模块名规则是一样的，且必须跟当前文件加载该模块的语句写法（上例<code>import &#123; A &#125; from './a'</code>）保持一致。</p><p>（2）不能创建新的顶层类型。也就是说，只能对<code>a.ts</code>模块中已经存在的类型进行扩展，不允许增加新的顶层类型，比如新定义一个接口<code>B</code>。</p><p>（3）不能对默认的<code>default</code>接口进行扩展，只能对 export 命令输出的命名接口进行扩充。这是因为在进行类型扩展时，需要依赖输出的接口名。</p><p>某些第三方模块，原始作者没有提供接口类型，这时可以在自己的脚本顶部加上下面一行命令。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&quot;模块名&quot;</span>;<br><span class="hljs-comment">// 例子declare module &quot;hot-new-module&quot;;</span><br></code></pre></td></tr></table></figure><p>加上上面的命令以后，外部模块即使没有类型，也可以通过编译。但是，从该模块输入的所有接口都将为<code>any</code>类型。</p><p>declare module 描述的模块名可以使用通配符。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;my-plugin-*&#x27;</span> &#123;  <br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PluginOptions</span> &#123;    <br>        <span class="hljs-attr">enabled</span>: <span class="hljs-built_in">boolean</span>;    <br>        <span class="hljs-attr">priority</span>: <span class="hljs-built_in">number</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params">options: PluginOptions</span>): <span class="hljs-built_in">void</span>;  <br>    <span class="hljs-keyword">export</span> = initialize;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面示例中，模块名<code>my-plugin-*</code>表示适配所有以<code>my-plugin-</code>开头的模块名（比如<code>my-plugin-logger</code>）。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Javascript忍者秘籍blog-1</title>
    <link href="/2024/04/21/Javascript%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8Dblog-1/"/>
    <url>/2024/04/21/Javascript%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8Dblog-1/</url>
    
    <content type="html"><![CDATA[<h1><code>Javascript</code>忍者秘籍(一)</h1><p>最近一直都在看这本书 感觉之前的js底子太差了 看这本书回顾一下吧(感觉有些概念都是没听过的)🌵</p><p>这篇主要写第四章理解函数调用的东西吧</p><p>调用函数时，隐式的函数参数 this 和 arguments 会被静默的传递给函数,可以像函数体内显式声明的参数一样使用</p><p><code>this</code> 表示调用函数的上下文对象</p><p><code>arguments</code> 表示函数调用过程中传递的所有参数。通过 arguments 参数可以访问 函数调用过程中传递的实际参数。</p><p>函数调用的方式 对 函数的隐式参数有很大的影响🍶</p><h3 id="1-隐式函数参数">1.隐式函数参数</h3><h4 id="arguments参数"><code>arguments</code>参数</h4><p>arguments参数表示传入函数的所有参数的集合。</p><p>使用arguments.length属性来获取传递给函数的实际参数个数。</p><p>通过数组下标的方式访问到arguments参数中的每个参数值，如arguments[2]将获取第三个参数。</p><p>arguments是一个类数组对象，不可以对arguments对象使用数组的方法。</p><p>在非严格模式下，arguments对象是函数参数的别名，修改arguments对象会影响对应的函数实参，反之亦然。</p><p>arguments作为参数别名使用时，会影响代码可读性，应该避免使用参数别名修改参数。在严格模式下通过arguments修改参数是不起作用的</p><h4 id="this参数"><code>this</code>参数</h4><p>this表示函数上下文，即与函数调用相关联的对象。(还是有很多抽象小题的 经典this指向问题)💢</p><p>但是，在<code>javascript</code>中，将一个函数作为方法调用仅仅是函数的一种调用方式。this参数是由函数的<strong>定义方式</strong>和<strong>调用方式</strong>决定</p><h3 id="2-函数调用方式">2.函数调用方式</h3><p>基本上是4种</p><ol><li>作为函数直接被调用；<code>myfunc()</code></li><li>作为方法关联在一个对象上，实现面向对象编程；<code>obj.myfunc()</code></li><li>作为构造函数调用，实例化一个对象；<code>new Myfunc()</code></li><li>通过函数的apply和call方法</li></ol><h4 id="作为函数被直接调用">作为函数被直接调用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*函数定义作为函数被调用*/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">aa</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-title function_">aa</span>(); <span class="hljs-comment">//=&gt;object.window</span><br><span class="hljs-comment">/*函数表达式作为函数被调用*/</span><br><span class="hljs-keyword">let</span> bb = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)<br>&#125;<br><span class="hljs-title function_">bb</span>(); <span class="hljs-comment">//=&gt;object.window</span><br><span class="hljs-comment">/*立即调用函数表达式作为函数被调用*/</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>)&#125;)();<br><span class="hljs-comment">//=&gt;object.window</span><br><br></code></pre></td></tr></table></figure><h4 id="作为对象方法被调用">作为对象方法被调用</h4><p>当一个函数被赋值一个对象的属性，并且通过对象属性引用的方式调用函数时，函数会作为对象的方法被调用。 作为对象方法调用的函数this值与对象关联，通过this可以访问所关联对象的其他方法和属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">aa</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">aa</span>()==<span class="hljs-variable language_">window</span>);<br><span class="hljs-comment">//=&gt;true</span><br><span class="hljs-keyword">var</span> obj1 = &#123;&#125;<br>obj1.<span class="hljs-property">aa</span> = aa;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-title function_">aa</span>()==obj1);<br><span class="hljs-comment">//=&gt;true</span><br><span class="hljs-keyword">var</span> obj2 = &#123;&#125;<br>obj2.<span class="hljs-property">bb</span> = aa;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2.<span class="hljs-title function_">bb</span>()==obj2);<br><span class="hljs-comment">//=&gt;true</span><br></code></pre></td></tr></table></figure><h4 id="作为构造函数调用">作为构造函数调用</h4><p>在函数调用之前加上关键字new，即为构造函数调用。</p><p>构造函数目的是用来创建和初始化一个新对象，然后将这个对象作为构造函数的返回值</p><p>使用关键字new调用函数会触发以下几个动作：🍔</p><ol><li>创建一个新的空对象；</li><li>该对象作为this参数传递给构造函数，成为构造函数的上下文；</li><li>新构造的对象作为new运算符的返回值。</li><li>如果构造函数返回一个对象，则该对象将作为整个表达式的返回值，而传入构造函数的this将被丢弃。</li><li>如果构建函数返回的是非对象类型，则忽略返回值，返回新创建的对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Ninja</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-comment">//这里的this表示Ninja函数的上下文</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">skulk</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-comment">//这里的this表示该匿名函数的上下文</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//skulk以对象的方式调用是，返回值是其关联的对象</span><br><span class="hljs-keyword">var</span> ninja1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ninja</span>();<br><span class="hljs-keyword">var</span> ninja2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Ninja</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ninja1.<span class="hljs-title function_">skulk</span>() == ninja1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ninja2.<span class="hljs-title function_">skulk</span>() == ninja2);<br><span class="hljs-comment">// skulk复制给一个变量后，直接调用函数时，非严格模式下skulk返回的值是window</span><br><span class="hljs-keyword">var</span> skulk = ninja2.<span class="hljs-property">skulk</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">skulk</span>() == <span class="hljs-variable language_">window</span>);<br><br></code></pre></td></tr></table></figure><h4 id="通过apply与call方法调用">通过apply与call方法调用</h4><p>javascript提供了可以显示指定任何对象作为函数的上下文的函数调用方式。每个函数都存在apply和call方法。通过apply与call方法来设置函数的上下文。</p><h5 id="call函数">call函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>.<span class="hljs-title function_">call</span>(context, arg1, arg2, ...)<br></code></pre></td></tr></table></figure><p><code>context</code> 是指定函数中的 <code>this</code> 关键字指向的对象，<code>arg1</code>, <code>arg2</code>, … 是传递给函数的参数</p><h5 id="apply函数">apply函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>.<span class="hljs-title function_">apply</span>(context, [argsArray])<br></code></pre></td></tr></table></figure><p><code>context</code> 是指定函数中的 <code>this</code> 关键字指向的对象，<code>argsArray</code> 是一个数组，其中包含要传递给函数的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">juggle</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> n=<span class="hljs-number">0</span>; n&lt;<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; n++)&#123;<br>        result+=<span class="hljs-variable language_">arguments</span>[n]<br>    &#125;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">result</span> = result;<br>&#125;<br><br><span class="hljs-keyword">var</span> ninja1 = &#123;&#125;;<br><span class="hljs-keyword">var</span> ninja2 = &#123;&#125;;<br><br>juggle.<span class="hljs-title function_">apply</span>(ninja1, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>])<br>juggle.<span class="hljs-title function_">call</span>(ninja2, <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ninja1.<span class="hljs-property">result</span> == <span class="hljs-number">15</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ninja2.<span class="hljs-property">result</span> == <span class="hljs-number">21</span>) <br></code></pre></td></tr></table></figure><p>apply和call功能类似，唯一的不同在于如何传递参数。apply和call第一个参数作为函数的上下文，apply第二个参数是一个包含参数值的数组。call可以传入任意数量参数，作为函数的参数。</p><h4 id="总结">总结!!!</h4><h5 id="总结四种函数的调用方式对this取值的影响">总结四种函数的调用方式对this取值的影响</h5><ul><li>如果作为函数调用，在非严格模式下，this指向全局window对象；在严格模式下，this指向undefined。</li><li>作为方法调用，this通常指向调用的对象</li><li>作为构造函数调用，this指向新创建的对象。</li><li>通过call或apply调用，this指向call或apply的第一个参数。</li></ul><h3 id="3-this指向问题-天天被拷打版">3.<code>this</code>指向问题!  (天天被拷打版)</h3><h4 id="在全局作用域">在全局作用域</h4><p><code>this-&gt;window</code></p><h4 id="在普通函数中">在普通函数中</h4><p>谁调用我 this指向谁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>            <span class="hljs-attr">fn1</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <br>            &#125;,<br>            <span class="hljs-attr">fn2</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>                <span class="hljs-title function_">fn3</span>() <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn3</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <br>        &#125;<br>        <span class="hljs-title function_">fn3</span>();<span class="hljs-comment">//this-&gt;window</span><br>        obj.<span class="hljs-title function_">fn1</span>();<span class="hljs-comment">//this-&gt;obj</span><br>        obj.<span class="hljs-title function_">fn2</span>();<span class="hljs-comment">//this-&gt;window</span><br><br></code></pre></td></tr></table></figure><h4 id="箭头函数的this">箭头函数的this</h4><p>箭头函数没有自己的this，箭头函数的this就是上下文中定义的this，因为箭头函数没有自己的this所以不能用做构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>); <br>   <span class="hljs-keyword">var</span> o=&#123;<br>       <span class="hljs-attr">a</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>           <span class="hljs-keyword">var</span> arr=[<span class="hljs-number">1</span>];<br>         <span class="hljs-comment">//就是定义所在对象中的this</span><br>         <span class="hljs-comment">//这里的this—&gt;o</span><br>           arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>             <span class="hljs-comment">//所以this -&gt; o</span><br>               <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>           &#125;)<br>       &#125;,<br>     <span class="hljs-comment">//这里的this指向window o是定义在window中的对象</span><br>       <span class="hljs-attr">b</span>:<span class="hljs-function">()=&gt;</span>&#123;<br>           <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>       &#125;,<br>       <span class="hljs-attr">c</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>           <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>       &#125;<br>   &#125;<br>   div.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<span class="hljs-comment">//this-&gt;window 这里的this就是定义上文window环境中的this</span><br>   &#125;);<br>   o.<span class="hljs-title function_">a</span>(); <span class="hljs-comment">//this-&gt;o</span><br>   o.<span class="hljs-title function_">b</span>();<span class="hljs-comment">//this-&gt;window</span><br>   o.<span class="hljs-title function_">c</span>();<span class="hljs-comment">//this-&gt;o 普通函数谁调用就指向谁</span><br><br></code></pre></td></tr></table></figure><h4 id="事件绑定中的this">事件绑定中的this</h4><p>基本上都是指向this-&gt;事件源的😆</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;div&#x27;</span>); <br>    div.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">//this-&gt;div</span><br>    &#125;);<br>    <br>    div.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">//this-&gt;div</span><br>    &#125;<br><br></code></pre></td></tr></table></figure><h4 id="定时器的this">定时器的this</h4><p>定时器中采用回调函数作为处理函数 回调函数的this-&gt;window</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">  <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">//this-&gt;window </span><br>    &#125;,<span class="hljs-number">500</span>)<br>    <br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">//this-&gt;window </span><br>    &#125;,<span class="hljs-number">500</span>)<br><span class="hljs-number">442</span><br></code></pre></td></tr></table></figure><h4 id="构造函数的this">构造函数的this</h4><p>构造函数配合new使用, 而new关键字会将构造函数中的this指向实例化对象，所以构造函数中的this-&gt;实例化对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name,age</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    &#125;<br>    <span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    person1.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;ggb&#x27;</span>;<br>    person1.<span class="hljs-property">age</span> = <span class="hljs-number">21</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1);<span class="hljs-comment">//Person &#123;name: &quot;ggb&quot;, age: 21&#125;</span><br>    <span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    person2.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;syj&#x27;</span>;<br>    person2.<span class="hljs-property">age</span> = <span class="hljs-number">19</span>;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2);<span class="hljs-comment">// Person &#123;name: &quot;syj&quot;, age: 19&#125;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git宝典</title>
    <link href="/2024/04/11/Git%E5%AE%9D%E5%85%B8/"/>
    <url>/2024/04/11/Git%E5%AE%9D%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<h1>Git宝典</h1><p>其实这次mini对我自身来说 学到了很多 技术这里就先不说了 终于意识到了git在多人协作写一个大项目的重要性 😆</p><h3 id="啥是Git">啥是Git</h3><p>我对<code>Git</code>这个东西的理解就是 在进行大型项目的开发时候 你不可能单兵作战 一般是有好多好多人一起的 这个时候怎么进行每个人之间的汇总勒</p><p>这个时候 就要用到<code>Git</code>了</p><p>说点官方的话术就是😒</p><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理项目</p><h3 id="Git是怎么工作的呢❓">Git是怎么工作的呢❓</h3><p>如图</p><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt="img"></p><p>具体都是什么意思勒</p><ul><li>Workspace：工作区 (就是你电脑能看到的)</li><li>Index / Stage：暂存区 (一般是在.<code>git</code>目录下的<code>index</code>文件下)</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h3 id="Git咋使用呢">Git咋使用呢</h3><h4 id="1-第一步肯定是新建Git库喽-🆕">1.第一步肯定是新建Git库喽 🆕</h4><p>有两种方法</p><p>1️⃣直接新建!</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init<br></code></pre></td></tr></table></figure><p>2️⃣克隆下来一个已经存在的库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone &quot;url&quot;<br></code></pre></td></tr></table></figure><h4 id="2-基本操作">2.基本操作</h4><p>该说不说这玩意真多啊😡</p><table><thead><tr><th><code>git add</code></th><th><code>添加文件到暂存区</code></th></tr></thead><tbody><tr><td><code>git status</code></td><td><code>查看仓库当前的状态 显示有变更的文件</code></td></tr><tr><td><code>git commit</code></td><td><code>提交暂存区到本地仓库</code></td></tr><tr><td><code>git mv</code></td><td><code>移动或重命名工作区文件</code></td></tr><tr><td><code>git log</code></td><td><code>查看历史提交记录</code></td></tr><tr><td><code>git blame</code></td><td><code>以列表形式查看指定文件的历史修改记录</code></td></tr><tr><td><code>git remote</code></td><td><code>远程仓库操作</code></td></tr><tr><td><code>git fetch</code></td><td><code>从远程获取代码库</code></td></tr><tr><td><code>git pull</code></td><td><code>下载远程代码并合并</code></td></tr><tr><td><code>git push</code></td><td><code>上传远程代码并合并 添加文件到本地暂存区</code></td></tr></tbody></table><ul><li><p>添加文件到暂存区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git add 文件名 //这样是添加某个问价<br>git add . //添加该目录下所有未被忽略的文件<br></code></pre></td></tr></table></figure><p>Tips:一般都忽略什么呢?🤔</p><p>一般都会忽略你的node_modules文件夹 因为依赖太多多多多了</p><p>​</p></li><li><p>提交更改到本地仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git commit -m &quot;说明&quot;<br></code></pre></td></tr></table></figure><p>这个说明也是有规范滴</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">feat - 新功能 feature<br>fix - 修复 bug<br>docs - 文档注释<br>style - 代码格式(不影响代码运行的变动)<br>refactor - 重构、优化(既不增加新功能，也不是修复bug)<br>perf - 性能优化<br>test - 增加测试<br>chore - 构建过程或辅助工具的变动<br>revert - 回退<br>build - 打包<br></code></pre></td></tr></table></figure><p>就像</p><p><img src="https://img2.imgtp.com/2024/04/13/LVOmRtNs.png" alt="git commit规范.png"></p></li></ul><p>这样写commit的话 就能非常清楚的看到你每次提交了一些什么</p><ul><li><p>分支管理</p><p>创建分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch (分支名)<br></code></pre></td></tr></table></figure><p>切换分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout (分支名)<br></code></pre></td></tr></table></figure><p>创建新的分支并且立即切换到该分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git checkout -b (分支名)<br></code></pre></td></tr></table></figure><p>合并分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git merge<br></code></pre></td></tr></table></figure><p>列出分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">//列出本地分支<br>git branch<br>//列出全部分支(包括远程分支)<br>git branch -a<br></code></pre></td></tr></table></figure><p>删除分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git branch -d (分支名)<br></code></pre></td></tr></table></figure></li></ul><h3 id="多人协作">多人协作</h3><p>在进行一个大型项目的时候 该怎么使用Git呢</p><p>就是刘总经常说的提PR了 😧</p><p>怎么提呢</p><p>首先你需要找到你用的大型项目仓库</p><p>然后fork!!!</p><p><img src="https://img2.imgtp.com/2024/04/13/6LtBRn7z.png" alt="fork.png"></p><p>然后回到你自己仓库</p><p>就能看到你的本地仓库了</p><ul><li><img src="https://img2.imgtp.com/2024/04/13/OnfI0lWy.png" alt="本地仓库.png"></li></ul><p>怎么提PR勒 🤔</p><p>点击你本地Contribute按钮 然后Open Pull Request</p><p><img src="https://img2.imgtp.com/2024/04/13/NuoY09og.png" alt="pr.png"></p><p>就可以跟本地一样写说明喽 标准也是跟commit的标准差不多的</p><p>小小小Tips:</p><p>在执行<code>git push</code>之前，为了防止远程仓库已有其他人提交的更改与你的更改产生冲突，要先执行<code>git pull</code>拉取远程仓库的代码，如果显示确有冲突，就要在本地手动更改冲突，可利用ide解决。 如果没有冲突，就可以直接推送。如果有冲突，解决冲突后重新执行<code>git add和git commit</code> ，再推送到远程仓库</p><p>就像</p><p><img src="https://img2.imgtp.com/2024/04/13/xIbOddt2.png" alt="git 手动操作.png"></p><p>基本上Git常用的就这些勒 好像博客也可以用Github Actions自动部署 以后有时间试试</p><p>😸</p>]]></content>
    
    
    <categories>
      
      <category>开发基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浅学webpack</title>
    <link href="/2024/03/23/%C7%B3%D1%A7webpack/"/>
    <url>/2024/03/23/%C7%B3%D1%A7webpack/</url>
    
    <content type="html"><![CDATA[<h1>webpack原理(一)</h1><h3 id="1-啥是webpack捏❔">1.啥是webpack捏❔</h3><p>本质上，<strong>webpack</strong> 是一个用于现代 JavaScript 应用程序的 <em>静态模块打包工具</em>。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 <a href="https://www.webpackjs.com/concepts/dependency-graph/">依赖图(dependency graph)</a>，然后将你项目中所需的每一个模块组合成一个或多个 <em>bundles</em>，它们均为静态资源，用于展示你的内容</p><h3 id="2-webpack主要流程">2.webpack主要流程</h3><p>感觉webpack可以分成三部分</p><ul><li><strong>构建的核心流程</strong></li><li><strong>loader 的作用</strong></li><li><strong>plugin 架构与常用套路</strong></li></ul><h3 id="3-核心流程解析-😆">3.核心流程解析 😆</h3><p>首先得知道这玩意最核心的功能是什么的吧</p><p>就像他官网说的一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs word">At its core, webpack is a static module bundler for modern JavaScript applications.<br></code></pre></td></tr></table></figure><p>也就是将各种类型的资源，包括图片、css、js等，转译、组合、拼接、生成 JS 格式的 bundler 文件</p><p><img src="https://img2.imgtp.com/2024/03/23/6xbAXLks.png" alt="屏幕截图 2024-03-23 012454.png"></p><p>这个过程核心完成了 <strong>[内容转换+资源合并]</strong> 两种功能</p><p>实际上包含三个阶段</p><ul><li><h4 id="初始化阶段：">初始化阶段：</h4></li></ul><ol><li><strong>初始化参数</strong>：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数</li><li><strong>创建编译器对象</strong>：用上一步得到的参数创建 <code>Compiler</code> 对象</li><li><strong>初始化编译环境</strong>：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等</li><li><strong>开始编译</strong>：执行 <code>compiler</code> 对象的 <code>run</code> 方法</li><li><strong>确定入口</strong>：根据配置中的 <code>entry</code> 找出所有的入口文件，调用 <code>compilition.addEntry</code> 将入口文件转换为 <code>dependence</code> 对象</li></ol><ul><li><h4 id="构建阶段：">构建阶段：</h4></li></ul><ol><li><strong>编译模块(make)</strong>：根据 <code>entry</code> 对应的 <code>dependence</code> 创建 <code>module</code> 对象，调用 <code>loader</code> 将模块转译为标准 JS 内容，调用 JS 解释器将内容转换为 AST 对象，从中找出该模块依赖的模块，再 递归 本步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li><strong>完成模块编译</strong>：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的 <strong>依赖关系图</strong></li></ol><ul><li><h4 id="生成阶段：">生成阶段：</h4></li></ul><ol><li><strong>输出资源(seal)</strong>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 <code>Chunk</code> 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li><strong>写入文件系统(emitAssets)</strong>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ol><p><img src="https://img2.imgtp.com/2024/03/23/czXM2g2f.png" alt="屏幕截图 2024-03-23 012530.png"></p><p>接下来说说细节部分吧 对上面一些听起来很高级的名词解释一手 :happy:</p><ul><li><p><code>Entry</code>：编译入口，webpack 编译的起点</p></li><li><p><code>Compiler</code>：编译管理器，webpack 启动后会创建 <code>compiler</code> 对象，该对象一直存活知道结束退出</p><p>这玩意记录了webpack运行环境的所有信息 插件可以通过它获取到webpack配置信息,像<code>entry output module</code>等配置</p></li><li><p><code>Compilation</code>：单次编辑过程的管理器，比如 <code>watch = true</code> 时，运行过程中只有一个 <code>compiler</code> 但每次文件变更触发重新编译时，都会创建一个新的 <code>compilation</code> 对象</p><p>它储存了当前的模块资源、编译生成的资源、变化的文件、以及被跟踪依赖的状态信息</p></li><li><p><code>Dependence</code>：依赖对象，webpack 基于该类型记录模块间依赖关系</p></li><li><p><code>Module</code>：webpack 内部所有资源都会以“module”对象形式存在，所有关于资源的操作、转译、合并都是以 “module” 为基本单位进行的</p></li><li><p><code>Chunk</code>：编译完成准备输出时，webpack 会将 <code>module</code> 按特定的规则组织成一个一个的 <code>chunk</code>，这些 <code>chunk</code> 某种程度上跟最终输出一一对应</p></li><li><p><code>Loader</code>：资源内容转换器，其实就是实现从内容 A 转换 B 的转换器</p></li><li><p><code>Plugin</code>：webpack构建过程中，会在特定的时机广播对应的事件，插件监听这些事件，在特定时间点介入编译过程</p></li></ul><h3 id="4-Plugin解析">4.<code>Plugin</code>解析</h3><p>看插件之前 首先想三个问题</p><p>什么是插件</p><p>什么时间点会有什么钩子被触发</p><p>在钩子回调中,如何影响编译状态</p><h4 id="What-什么是插件🚘">What: 什么是插件🚘</h4><p>先从形态上来看 插件是个带有<code>apply</code>函数的类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomePlugin</span> &#123;<br><span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>)&#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>apply</code> 函数运行时会得到参数 <code>compiler</code> ，以此为起点可以调用 <code>hook</code> 对象注册各种钩子回调，例如： <code>compiler.hooks.make.tapAsync</code> ，这里面 <code>make</code> 是钩子名称，<code>tapAsync</code> 定义了钩子的调用方式，webpack 的插件架构基于这种模式构建而成，插件开发者可以使用这种模式在钩子回调中，插入特定代码。webpack 各种内置对象都带有 <code>hooks</code> 属性，比如 <code>compilation</code> 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomePlugin</span> &#123;<br>    <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>        compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">thisCompilation</span>.<span class="hljs-title function_">tap</span>(<span class="hljs-string">&#x27;SomePlugin&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">compilation</span>) =&gt;</span> &#123;<br>            compilation.<span class="hljs-property">hooks</span>.<span class="hljs-property">optimizeChunkAssets</span>.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-string">&#x27;SomePlugin&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;&#125;);<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="When-什么时候会触发钩子-📦">When: 什么时候会触发钩子 📦</h4><p>官网对钩子的说明都比较简短</p><p>直接看几个例子吧</p><p><code>compiler.hooks.compilation</code> ：</p><ul><li>时机：启动编译创建出 compilation 对象后触发</li><li>参数：当前编译的 compilation 对象</li><li>示例：很多插件基于此事件获取 compilation 实例</li></ul><p><code>compiler.hooks.make</code>：</p><ul><li>时机：正式开始编译时触发</li><li>参数：同样是当前编译的 <code>compilation</code> 对象</li><li>示例：webpack 内置的 <code>EntryPlugin</code> 基于此钩子实现 <code>entry</code> 模块的初始化</li></ul><p><code>compilation.hooks.optimizeChunks</code> ：</p><ul><li>时机： <code>seal</code> 函数中，<code>chunk</code> 集合构建完毕后触发</li><li>参数：<code>chunks</code> 集合与 <code>chunkGroups</code> 集合</li><li>示例： <code>SplitChunksPlugin</code> 插件基于此钩子实现 <code>chunk</code> 拆分优化</li></ul><p><code>compiler.hooks.done</code>：</p><ul><li>时机：编译完成后触发</li><li>参数： <code>stats</code> 对象，包含编译过程中的各类统计信息</li><li>示例： <code>webpack-bundle-analyzer</code> 插件基于此钩子实现打包分析</li></ul><p>看这个钩子时候我直接看 触发时机 传递参数 示例代码</p><p>首先看触发时机勒</p><p>触发时机是与webpack工作过程紧密相关的,大体上从启动到结束,<code>compiler</code>对象逐次触发以下钩子</p><p><img src="https://img2.imgtp.com/2024/03/23/1p0WM3NF.png" alt="屏幕截图 2024-03-23 012707.png"></p><p>而<code>compilation</code>对象逐次触发:</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de1f0d05a1274e6d86959b60a3d98742~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image (1).png"></p><p>就都是嘟嘟嘟嘟嘟嘟长串 😓</p><p>我自己的理解是 这个时机就是几个情况</p><ul><li>创建出这个对象触发</li><li>正式开始编译就触发</li><li>函数构建完毕后触发</li></ul><p>传递参数</p><p>我在他的配置里没怎么找到 感觉无非传点modules之类的东西</p><p>示例代码</p><p>webpack这钩子实话实说</p><p>抽象程度是小大的 我感觉最好的学习办法 就是查询其他插件中如何使用这些钩子 不然你就看吧 一看一个不吱声😭</p><h4 id="How-如何影响编译状态捏">How 如何影响编译状态捏</h4><p>webpack的插件体系跟平常看到的不太一样 hooks回调由webpack决定何时 以何种方式 而在hooks回调内部可以直接修改状态 调用上下文api等方式webpack产生 一些影响</p><p>举个🏮子</p><p><code>EntryPlugin</code>插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EntryPlugin</span> &#123;<br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">compilation</span>.<span class="hljs-title function_">tap</span>(<br>      <span class="hljs-string">&quot;EntryPlugin&quot;</span>,<br>      <span class="hljs-function">(<span class="hljs-params">compilation, &#123; normalModuleFactory &#125;</span>) =&gt;</span> &#123;<br>        compilation.<span class="hljs-property">dependencyFactories</span>.<span class="hljs-title function_">set</span>(<br>          <span class="hljs-title class_">EntryDependency</span>,<br>          normalModuleFactory<br>        );<br>      &#125;<br>    );<br><br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">make</span>.<span class="hljs-title function_">tapAsync</span>(<span class="hljs-string">&quot;EntryPlugin&quot;</span>, <span class="hljs-function">(<span class="hljs-params">compilation, callback</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> &#123; entry, options, context &#125; = <span class="hljs-variable language_">this</span>;<br><br>      <span class="hljs-keyword">const</span> dep = <span class="hljs-title class_">EntryPlugin</span>.<span class="hljs-title function_">createDependency</span>(entry, options);<br>      compilation.<span class="hljs-title function_">addEntry</span>(context, dep, options, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-title function_">callback</span>(err);<br>      &#125;);<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里面 webpack会将上下文信息以参数或<code>this</code>形式传递给钩子回调用</p><p>在回调中可以调用上下文对象的方法或者直接修改上下文对象属性的方式，对原定的流程产生 side effect。所以想纯熟地编写插件，除了要理解调用时机，还需要了解我们可以用哪一些api，例如：</p><ul><li><code>compilation.addModule</code>：添加模块，可以在原有的 <code>module</code> 构建规则之外，添加自定义模块</li><li><code>compilation.emitAsset</code>：直译是“提交资产”，功能可以理解将内容写入到一个特定路径</li><li><code>compilation.addEntry</code>：添加入口，功能上与直接定义 <code>entry</code> 配置相同</li><li><code>module.addError</code>：添加编译错误信息</li></ul><h3 id="5-Loader介绍">5.Loader介绍</h3><p>看一下<code>loader</code>在编译流程中的生效位置</p><p><img src="https://img2.imgtp.com/2024/03/23/IYzGYIPf.png" alt="屏幕截图 2024-03-23 012734.png"></p><p>在这个流程图里,<code>runloaders</code>会调用用户所配置的loader集合读取,转移资源,前面的内容可以千奇百怪👽</p><p>但是转译之后一般都是输出Javascript文本,webpack才可以继续处理模块依赖</p><p>理解了这个基本逻辑,loader职责基本上也知道了 就是把内容A =&gt;内容B</p>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>自定义React hooks</title>
    <link href="/2024/03/08/%E8%87%AA%E5%AE%9A%E4%B9%89React%20Hooks/"/>
    <url>/2024/03/08/%E8%87%AA%E5%AE%9A%E4%B9%89React%20Hooks/</url>
    
    <content type="html"><![CDATA[<h1>自定义<code>React Hooks</code></h1><h3 id="1-为什么会出现hooks这个东西捏-❓">1.为什么会出现<code>hooks</code>这个东西捏 ❓</h3><p>刚看<code>hooks</code> 就出现了这个问题 <code>hooks</code>出现的意义在哪里呢</p><p><code>hooks</code>能解决什么问题</p><p><code>React</code>中组件有两种写法 一种类组件 一种函数组件</p><p>但是函数组件相对于类组件来说有一个小小滴缺点  就是没有<code>state</code> 😔</p><p>所以<code>hooks</code>就应运而生勒😀</p><p><code>hooks</code>是一类特殊的函数 允许在React的函数式组件中&quot;钩入&quot;状态,生命周期等其他<code>React</code>的特性</p><p>提供了一种无需类组件的方式,使得现在在函数式组件中可以使用像 <code>this.state</code>,<code>this.props</code>的概念勒🌵</p><h3 id=""></h3><h3 id="2-那hooks都这么厉害了-为什么还要有自定义的hooks捏❔">2.那<code>hooks</code>都这么厉害了 为什么还要有自定义的<code>hooks</code>捏❔</h3><p>正常的<code>useState</code>接受两个参数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> [state,setState]=<span class="hljs-title function_">useState</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>正常在类组件中<code>setState</code>会支持两个参数: 一个是更新后的<code>state</code>或者回调式更新的<code>state</code> 另一个参数是更新后的回调函数</p><p><code>tips</code>:什么是回调函数😓</p><p>回调 (callback) 是<strong>作为参数传递给另一个函数的函数</strong> ,并在被调用函数执行完毕后被调用</p><p>个人的小理解: 回调函数就是先定义了<code>functionA</code>然后再定义了<code>functionB</code></p><p>但是在使用时候先用了<code>functionB</code> 并且把<code>functionA</code>当成了参数给了<code>functionB</code></p><p><code>useState</code> hook并不直接支持像类组件中的<code>setState</code>方法那样可以接收第二个参数作为回调函数。<code>useState</code> hook返回的更新函数只能用于更新状态，并且不会提供回调函数的选项</p><p>所以自定义<code>hooks</code>就出现啦</p><h3 id="3-来自定义useState吧🍶">3.来自定义<code>useState</code>吧🍶</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">useStatePro</span> =(<span class="hljs-params">initState</span>)=&gt;&#123;<br>    <span class="hljs-keyword">const</span> [state,setState]=<span class="hljs-title function_">useState</span>(initState);<br>    <span class="hljs-comment">//存储一手回调函数</span><br>    <span class="hljs-keyword">const</span> isUpdate=<span class="hljs-title function_">useRef</span>()<br>    <span class="hljs-comment">//定义一个新函数喽 (接受一个新状态和一个回调函数)</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">setStatePro</span> =(<span class="hljs-params">newState,cb</span>)=&gt;&#123;<br>        <span class="hljs-comment">//使用setState更新状态 把回调函数储存在current里 </span><br>        <span class="hljs-comment">//如果newState是个函数的情况下 就计算新状态 </span><br>        <span class="hljs-title function_">setState</span>(<br>        <span class="hljs-function"><span class="hljs-params">prev</span>=&gt;</span>&#123;<br>            isUpdate.<span class="hljs-property">current</span>=cb<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> newState=<span class="hljs-string">&#x27;function&#x27;</span> ? <span class="hljs-title function_">newState</span>(prev):newState<br>        &#125;<br>        )<br>    &#125;<br>    <span class="hljs-comment">//检查一下current有无回调函数 有就直接执行</span><br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">if</span>(isUpdate.<span class="hljs-property">current</span>)<br>            &#123;<br><span class="hljs-keyword">return</span> isUpdate.<span class="hljs-title function_">current</span>()<br>            &#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> [state,useStatePro]<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就实现了<code>useState</code>的功能 但是多了一个在状态更新后执行回调函数的功能</p><h3 id="4-自定义一个更新函数useUpdate">4.自定义一个更新函数<code>useUpdate</code></h3><p>如果正常使用<code>hooks</code>想让组件重新渲染 一般是要更新state的</p><p>但是有的时候可能一个state掌握着好几个组件的生死大权😈</p><p>不能就为了一个小小的组件就让state作出无意义的更新</p><p>这时候可以想想能不能定义一个更新的<code>hooks</code>来优雅一些实现组件的强制更新</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Update</span>=(<span class="hljs-params"></span>)=&gt;&#123;<br>    <span class="hljs-keyword">const</span> [,setFlag]=<span class="hljs-title function_">useState</span>()<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">update</span>=(<span class="hljs-params"></span>)=&gt;&#123;<br>        <span class="hljs-comment">//更新一手时间</span><br>        <span class="hljs-title function_">setFlag</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>())<br>    &#125;<br>    <span class="hljs-keyword">return</span> update<br>&#125;<br></code></pre></td></tr></table></figure><p>发现这个函数返回了一个函数 这个函数就是用来强制更新的</p><p>咋使用他捏💅</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Time</span>=(<span class="hljs-params"></span>)=&gt;&#123;<br>    <span class="hljs-keyword">const</span> update=<span class="hljs-title function_">useUpdate</span>();<br>    <span class="hljs-keyword">return</span>(<br>        &#123;<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()&#125;<br>    &lt;div&gt;<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onCLick</span>=<span class="hljs-string">&#123;update&#125;</span>&gt;</span>更新喽<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>&lt;/div&gt;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-自定义hooks实现redux">5.自定义hooks实现<code>redux</code></h3><p><code>Redux</code>目前来说还是常用的管理状态的工具 但是<code>Redux</code>需要遵守的规则和步骤有点小多😡</p><p>所以来制作一个属于自己的<code>Redux</code></p><h4 id="1-首先先把应用接口做好">1.首先先把应用接口做好</h4><p>在顶部引入<code>Provider</code>组件为所有的儿孙组件提供所有数据源<code>store</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span>, &#123;render&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/App&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Provider</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store/provider&#x27;</span><br><span class="hljs-comment">// 挂载节点</span><br><span class="hljs-title function_">render</span>((<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Provider</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">App</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Provider</span>&gt;</span></span><br>), <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;app&#x27;</span>)<br>)<br></code></pre></td></tr></table></figure><h4 id="2-然后就可以开始设计store啦-happy">2.然后就可以开始设计<code>store</code>啦:happy:</h4><p>首先就是数据项</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">//初始化数据</span><br><span class="hljs-keyword">const</span> initState=&#123;<br> <span class="hljs-attr">count</span>:<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//reducer 处理器</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">reducer</span> =(<span class="hljs-params">state,action</span>)=&gt;&#123;<br>    <span class="hljs-keyword">const</span>&#123;type,payload&#125;=action<br>    <span class="hljs-keyword">switch</span>(type)&#123;<br>            <span class="hljs-keyword">case</span><span class="hljs-string">&#x27;ADD_COUNT&#x27;</span>:<span class="hljs-keyword">return</span>&#123;...state ,<span class="hljs-attr">count</span>:state.<span class="hljs-property">count</span>+<span class="hljs-number">1</span>&#125;<br>            <span class="hljs-keyword">default</span> : <span class="hljs-keyword">return</span> state;<br>    &#125;<br>&#125;<span class="hljs-comment">// 创建上下文</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Context</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>()<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Provider</span> = (<span class="hljs-params">props</span>) =&gt; &#123;<br><span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initState)<br><span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Context.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;state,</span> <span class="hljs-attr">dispatch</span>&#125;&#125;&gt;</span></span><br><span class="language-xml">        &#123;props.children&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Context.Provider</span>&gt;</span></span><br>)<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; <span class="hljs-title class_">Context</span>, <span class="hljs-title class_">Provider</span> &#125;<br><br></code></pre></td></tr></table></figure><p>在这个数据项中可以看出 initState<code> </code>reducer<code>的定义和使用</code>redux`是一模一样的</p><p>重点看下面的创建的上下文 首先通过<code>React.createContext()</code>创建一个空的上下文</p><p>然后定义<code>Provider</code>这个组件 在内部用<code>useReducer</code>把<code>reducer</code>和初始化的<code>initState</code>传入进去</p><p>返回的<code>state</code>和<code>dispatch</code>提供到<code>Provider</code>作为数据源</p><p>数据项聚合一下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 聚合count、todo这些数据项</span><br><span class="hljs-keyword">const</span> providers = [<br>    <span class="hljs-title class_">Count</span>.<span class="hljs-property">Provider</span>,<br>    <span class="hljs-title class_">Todo</span>.<span class="hljs-property">Provider</span><br>];<br><span class="hljs-comment">// 递归包裹Provider</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">ProvidersComposer</span> = (<span class="hljs-params">props</span>) =&gt; (<br>    props.<span class="hljs-property">providers</span>.<span class="hljs-title function_">reduceRight</span>(<span class="hljs-function">(<span class="hljs-params">children, Parent</span>) =&gt;</span> (<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Parent</span>(&#123;children&#125;)<br>    ), props.<span class="hljs-property">children</span>)<br>)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Provider</span> = (<span class="hljs-params">props</span>) =&gt; &#123;<br><span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ProvidersComposer</span> <span class="hljs-attr">providers</span>=<span class="hljs-string">&#123;providers&#125;</span>&gt;</span></span><br><span class="language-xml">        &#123;props.children&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ProvidersComposer</span>&gt;</span></span><br>)<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Provider</span><br></code></pre></td></tr></table></figure><p>最后出来的组件结构： <code>Provider &gt; Context.Provider &gt; Context.Provider &gt; App</code> 我们通过ProviderComposer进行递归包裹，把每个<code>Provider</code>进行一层一层的包裹 这里使用了<code>parent(&#123;children&#125;)</code>替代了<code>&lt;Parent&gt;&#123;children&#125;&lt;/Parent&gt;</code>，这样的做法可以减少一层嵌套结构。</p><p>如何使用捏💩</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useContext, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-comment">// 引入count数据源</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">CountStore</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store/modules/count&#x27;</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">App</span> = (<span class="hljs-params">props</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 通过useContext使用Count这个store的上下文</span><br>    <span class="hljs-keyword">const</span> &#123;state, dispatch&#125; = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">CountStore</span>.<span class="hljs-property">Context</span>)<br>    <span class="hljs-comment">// 每秒更新count</span><br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ADD_COUNT&#x27;</span> &#125;)<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;, [])<br>    <br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="language-xml">            &#123;JSON.stringify(state)&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span><br><br></code></pre></td></tr></table></figure><p>这样就实现啦一个小型<code>redux</code> 感觉比正常的<code>redux</code>会好用一些捏</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>React hook</title>
    <link href="/2024/02/17/React%20hook/"/>
    <url>/2024/02/17/React%20hook/</url>
    
    <content type="html"><![CDATA[<h1><code>React hook</code></h1><h3 id="Hook-的优势">Hook 的优势</h3><ul><li>Hook 使你在无需改变组件结构的情况下复用状态逻辑（自定义 Hook）</li><li>Hook 将组件中互相关联的部分拆分成更小的函数（比如设置订阅或请求数据）</li><li>Hook 使你在非 class 的情况下可以使用更多的 React 特性</li></ul><h3 id="Hook-使用规则">Hook 使用规则</h3><p>Hook 就是 <code>Javascript</code> 函数，使用它们时有两个额外的规则：</p><ul><li>只能在<strong>函数外层</strong>调用 Hook，不要在循环、条件判断或者子函数中调用</li><li>只能在 <strong>React 的函数组件</strong> 和<strong>自定义 Hook</strong> 中调用 Hook。不要在其他 JavaScript 函数中调用</li></ul><p>在组件中 React 是通过判断 Hook 调用的顺序来判断某个 state 对应的 <code>useState</code>的，所以必须保证 Hook 的调用顺序在多次渲染之间保持一致，React 才能正确地将内部 state 和对应的 Hook 进行关联</p><h2 id="useState"><code>useState</code></h2><p><code>useState</code> 可以使函数组件像类组件一样拥有 <code>state</code>，函数组件通过 <code>useState</code> 可以让组件重新渲染，更新视图</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> [ ①state , ②dispatch ] = <span class="hljs-title function_">useState</span>(③initData)<br></code></pre></td></tr></table></figure><p>① <code>state</code>，目的提供给 <code>UI</code> ，作为渲染视图的数据源</p><p>② <code>dispatchAction</code>(setState) 改变 state 的函数，可以理解为推动函数组件渲染的渲染函数</p><p>③ <code>initData</code> 有两种情况，第一种情况是非函数，将作为 state 初始化的值。 第二种情况是函数，函数的返回值作为 <code>useState</code> 初始化的值</p><p>基础用法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">DemoState</span> = (<span class="hljs-params">props</span>) =&gt; &#123;<br>   <span class="hljs-comment">/* number为此时state读取值 ，setNumber为派发更新的函数 */</span><br>   <span class="hljs-keyword">let</span> [number, setNumber] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">/* 0为初始值 */</span><br>   <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123; number &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">       <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> ()=&gt;</span> &#123;</span><br><span class="language-xml">         setNumber(number+1)</span><br><span class="language-xml">         console.log(number) /* 这里的number是不能够即使改变的  */</span><br><span class="language-xml">       &#125; &#125; &gt;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>``useState 注意事项`：</strong></p><p>① 在函数组件一次执行上下文中，state 的值是固定不变的</p><p>② 如果两次 <code>dispatchAction</code> 传入相同的 state 值，那么组件就不会更新</p><p>③ 当触发 <code>dispatchAction</code> 在当前执行上下文中获取不到最新的 <code>state</code>, 只有在下一次组件 rerender 中才能获取到。</p><h2 id="useReducer"><code>useReducer</code></h2><p>组件中可能有多个位置包括了对某个状态的修改操作</p><p><code>useReducer</code>用于统一管理状态的操作方式</p><p>使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为父组件可以向子组件传递 <code>dispatch</code> 而不是回调函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span>[state,dispatch]= useReducer (countReducer,<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>① 更新之后的 state 值。</p><p>② 派发更新的 dispatch 函数, 本质上和 <code>useState</code> 的 dispatch是一样的。</p><p>③ 一个函数<code>countReducer</code> 常规reducer里面的 state 和action</p><p>准备一个用来进行状态功能管理的函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">countReducer</span> (state,action)<br><span class="hljs-comment">//state reducer管理状态的是哪个</span><br><span class="hljs-comment">//action 对这个状态进行哪些操作</span><br>&#123;<br>    <span class="hljs-keyword">switch</span>(action.<span class="hljs-property">type</span>)<br>    &#123;<br>        <span class="hljs-keyword">case</span><span class="hljs-string">&quot;increment&quot;</span> :<span class="hljs-keyword">return</span> state+<span class="hljs-number">1</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;decrement&quot;</span>:<span class="hljs-keyword">return</span> state-<span class="hljs-number">1</span> <br>        <span class="hljs-attr">default</span>:<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>()<br>    &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span> ()<br>&#123;<br>    <span class="hljs-comment">//state 状态当前值</span><br>    <span class="hljs-comment">//dispatch 用来进行状态修改的触发器 (函数值) </span><br>    <span class="hljs-keyword">const</span> [state,dispath]=<span class="hljs-title function_">useReducer</span>(countReducer,<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleIncrement</span>=(<span class="hljs-params"></span>)=&gt;<span class="hljs-title function_">dispath</span>(&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&quot;increment&quot;</span>&#125;)<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleDecrement</span>=(<span class="hljs-params"></span>)=&gt;<span class="hljs-title function_">dispath</span>(&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">&quot;decrement&quot;</span>&#125;)<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleIncrement&#125;</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;state&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleDecrement&#125;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="useSyncExternalStore"><code>useSyncExternalStore</code></h2><p>不懂以后再说</p><h2 id="useTransition"><code>useTransition</code></h2><p>别急</p><h2 id="useDeferredValue"><code>useDeferredValue</code></h2><p>你也别急</p><h2 id="useEffect"><code>useEffect</code></h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> destory<br>&#125;,dep)<br></code></pre></td></tr></table></figure><p>第一个参数<code>callback</code>返回的 <code>destroy</code>    作为下一次<code>callback</code>执行之前调用 用于清楚上一次<code>callback</code>产生的副作用</p><p>第二个参数作为依赖项，是一个数组，可以有多个依赖项，依赖项改变，执行上一次callback 返回的 <code>destory</code> ，和执行新的 effect 第一个参数 callback</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">/* 模拟数据交互 */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserInfo</span>(<span class="hljs-params">a</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123; <br>            <span class="hljs-title function_">resolve</span>(&#123;<br>                <span class="hljs-attr">name</span>:a,<br>                <span class="hljs-attr">age</span>:<span class="hljs-number">16</span>,<br>            &#125;) <br>        &#125;,<span class="hljs-number">500</span>)<br>    &#125;)<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Demo</span> = (<span class="hljs-params">&#123; a &#125;</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> [ userMessage , setUserMessage ] :any= <span class="hljs-title function_">useState</span>(&#123;&#125;)<br>    <span class="hljs-keyword">const</span> div= <span class="hljs-title function_">useRef</span>()<br>    <span class="hljs-keyword">const</span> [number, setNumber] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>)<br>    <span class="hljs-comment">/* 模拟事件监听处理函数 */</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleResize</span> =(<span class="hljs-params"></span>)=&gt;&#123;&#125;<br>  <span class="hljs-comment">/* useEffect使用 ，这里如果不加限制 ，会是函数重复执行，陷入死循环*/</span><br>    <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-comment">/* 请求数据 */</span><br>        <span class="hljs-title function_">getUserInfo</span>(a).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>            <span class="hljs-title function_">setUserMessage</span>(res)<br>        &#125;)<br>        <span class="hljs-comment">/* 定时器 延时器等 */</span><br>        <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">666</span>),<span class="hljs-number">1000</span>)<br>        <span class="hljs-comment">/* 操作dom  */</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(div.<span class="hljs-property">current</span>) <span class="hljs-comment">/* div */</span><br>        <span class="hljs-comment">/* 事件监听等 */</span><br>        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, handleResize)<br>        <span class="hljs-comment">/* 此函数用于清除副作用 */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-built_in">clearInterval</span>(timer) <br>            <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, handleResize)<br>        &#125;<br>          <span class="hljs-comment">/* 只有当props-&gt;a和state-&gt;number改变的时候 ,useEffect副作用函数重新执行 ，如果此时数组为空[]，证明函数只有在初始化的时候执行一次相当于componentDidMount */</span><br>    &#125;,[ a ,number ])<br>    <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;div&#125;</span> &gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123; userMessage.name &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123; userMessage.age &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> ()=&gt;</span> setNumber(1) &#125; &gt;&#123; number &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如上在 <code>useEffect</code> 中做的功能如下：</p><ul><li>① 请求数据。</li><li>② 设置定时器,延时器等。</li><li>③ 操作 <code>Dom </code></li><li>④ 注册事件监听器, 事件绑定</li><li>⑤ 还可以清除定时器，延时器，解绑事件监听器等。</li></ul><h2 id="useLayoutEffect"><code>useLayoutEffect</code></h2><p>别急</p><h2 id="useInsertionEffect"><code>useInsertionEffect</code></h2><p>你也别急</p><h2 id="useContext"><code>useContext</code></h2><p>可以用<code>useContext</code> 来获取父级组件传递过来的<code>context</code>的值</p><p>这个当前值就是最近的父级组件<code>Provider</code> 设置的<code>value</code>值 ,</p><p><code>useContext</code> 参数一般是由<code>createContext</code>方式创建的,也可以父级上下文<code>context</code>传递的(参数是<code>context</code> )</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> contextValue = <span class="hljs-title function_">useContext</span>(context)<br></code></pre></td></tr></table></figure><p><code>useContext</code> 接受一个参数 一般都是 context 对象，返回值为 context 对象内部保存的 value 值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">/* 用useContext方式 */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">DemoContext</span> = (<span class="hljs-params"></span>)=&gt; &#123;<br>    <span class="hljs-keyword">const</span> value= <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">Context</span>)<br>    <span class="hljs-comment">/* my name is alien */</span><br><span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> my name is &#123; value.name &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-comment">/* 用Context.Consumer 方式 */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">DemoContext1</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Context.Consumer</span>&gt;</span></span><br><span class="language-xml">         &#123;/*  my name is alien  */&#125;</span><br><span class="language-xml">        &#123; (value)=&gt; <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> my name is &#123; value.name &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> &#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Context.Consumer</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ()=&gt;&#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Context.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">name:</span>&#x27;<span class="hljs-attr">alien</span>&#x27; , <span class="hljs-attr">age:18</span> &#125;&#125; &gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">DemoContext</span> /&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">DemoContext1</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Context.Provider</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="useRef"><code>useRef</code></h2><p><code>useRef</code> 可以用来获取元素，缓存状态，接受一个状态 <code>initState</code> 作为初始值，返回一个 ref 对象 cur, cur 上有一个 current 属性就是 ref 对象需要获取的内容</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> cur = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useRef</span>(initState)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cur.<span class="hljs-property">current</span>)<br></code></pre></td></tr></table></figure><p><code>useRef</code> 创建的 ref 对象就是一个普通的对象，而 <code>useRef()</code> 和自建一个 <code>&#123;current: ...&#125;</code> 对象的唯一区别是，<code>useRef</code> 会在每次渲染时返回同一个 ref 对象</p><h3 id="useRef-基础用法："><code>useRef 基础用法：</code></h3><p><code>useRef</code>来获取DOM节点</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">DemoUseRef</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>    <span class="hljs-keyword">const</span> dom= <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handerSubmit</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>        <span class="hljs-comment">/*  &lt;div &gt;表单组件&lt;/div&gt;  dom 节点 */</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dom.<span class="hljs-property">current</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        &#123;/* ref 标记当前dom节点 */&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;dom&#125;</span> &gt;</span>表单组件<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span>=&gt;</span>handerSubmit()&#125; &gt;提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>useRef 保存状态</p><p>可以利用 useRef 返回的 ref 对象来保存状态，只要当前组件不被销毁，那么状态就会一直存在</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> status = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">false</span>)<br><span class="hljs-comment">/* 改变状态 */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleChangeStatus</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  status.<span class="hljs-property">current</span> = <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="useImperativeHandle"><code>useImperativeHandle</code></h2><p>这什么玩意</p><h2 id="useMemo"><code>useMemo</code></h2><p>useMemo 可以在函数组件 render 上下文中同步执行一个函数逻辑，这个函数的返回值可以作为一个新的状态缓存起来。那么这个 hooks 的作用就显而易见了</p><p>场景一：在一些场景下，需要在函数组件中进行大量的逻辑计算，那么我们不期望每一次函数组件渲染都执行这些复杂的计算逻辑，所以就需要在 useMemo 的回调函数中执行这些逻辑，然后把得到的产物（计算结果）缓存起来就可以了。</p><p>场景二：React 在整个更新流程中，<code>diff</code> 起到了决定性的作用，比如 <code>Context</code> 中的 <code>provider</code> 通过 <code>diff value</code> 来判断是否更新</p><h3 id="useMemo-基础介绍："><code>useMemo 基础介绍：</code></h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> cacheSomething = <span class="hljs-title function_">useMemo</span>(create,deps)<br></code></pre></td></tr></table></figure><p>① create：第一个参数为一个函数，函数的返回值作为缓存值，如上 demo 中把 Children 对应的 element 对象，缓存起来。</p><p>② deps： 第二个参数为一个数组，存放当前 useMemo 的依赖项，在函数组件下一次执行的时候，会对比 deps 依赖项里面的状态，是否有改变，如果有改变重新执行 create ，得到新的缓存值。</p><p>③ <code>cacheSomething</code>：返回值，执行 create 的返回值。如果 deps 中有依赖项改变，返回的重新执行 create 产生的值，否则取上一次缓存值。</p><h3 id="useMemo-基础用法："><code>useMemo 基础用法：</code></h3><p>派生新状态：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Scope</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> keeper = <span class="hljs-title function_">useKeep</span>()<br>    <span class="hljs-keyword">const</span> &#123; cacheDispatch, cacheList, hasAliveStatus &#125; = keeper<br>   <br>    <span class="hljs-comment">/* 通过 useMemo 得到派生出来的新状态 contextValue  */</span><br>    <span class="hljs-keyword">const</span> contextValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">cacheDispatch</span>: cacheDispatch.<span class="hljs-title function_">bind</span>(keeper),<br>            <span class="hljs-attr">hasAliveStatus</span>: hasAliveStatus.<span class="hljs-title function_">bind</span>(keeper),<br>            <span class="hljs-attr">cacheDestory</span>: <span class="hljs-function">(<span class="hljs-params">payload</span>) =&gt;</span> cacheDispatch.<span class="hljs-title function_">call</span>(keeper, &#123; <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">ACTION_DESTORY</span>, payload &#125;)<br>        &#125;<br>      <br>    &#125;, [keeper])<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">KeepaliveContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;contextValue&#125;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">KeepaliveContext.Provider</span>&gt;</span></span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>如上通过 <code>useMemo</code> 得到派生出来的新状态 <code>contextValue</code> ，只有 keeper 变化的时候，才改变 Provider 的 value</p><h2 id="useCallback"><code>useCallback</code></h2><p>这个好像有点急 但是先别急</p><h2 id="useDebugValue"><code>useDebugValue</code></h2><p>这什么玩意</p><h2 id="useId"><code>useId</code></h2><p>看不懂思密达</p><h2 id="自定义hook"><code>自定义hook</code></h2><p>别急</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>组件通信</title>
    <link href="/2024/02/17/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <url>/2024/02/17/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1><code>React组件通信</code></h1><p>组件</p><p><code>dom</code>组件 <code>react</code>支持的<code>html</code>和<code>svg</code>标签</p><h3 id="props"><code>props</code></h3><p>什么是<code>props</code>  <code>html</code>属性的功能</p><p><code>dom</code>属性</p><p>类名 <code>className</code></p><p>样式</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx">style=&#123;<br>    &#123;<br>    <span class="hljs-attr">width</span>:<span class="hljs-string">&#x27;100vh&#x27;</span>,<br>    <span class="hljs-attr">height</span>:<span class="hljs-number">100</span>,<br>    <span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">&#x27;grey&#x27;</span><br>    <span class="hljs-comment">//带-的写成驼峰</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以书写变量</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> imgStyle=&#123;<br>    <span class="hljs-attr">width</span>:<span class="hljs-string">&#x27;100vh&#x27;</span>,<br>    <span class="hljs-attr">height</span>:<span class="hljs-number">100</span>,<br>    <span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">&#x27;grey&#x27;</span><br>&#125;<br><span class="hljs-keyword">return</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;imgStyle&#125;/</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br></code></pre></td></tr></table></figure><p><code>jsx</code>展开语法</p><p>把所有属性书写为一个变量</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> image <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./logo.svg&#x27;</span><br><span class="hljs-keyword">const</span> imgData=&#123;<br>    className=<span class="hljs-string">&#x27;small&#x27;</span>,<br>    <span class="hljs-attr">style</span>:&#123;<br>    <span class="hljs-attr">width</span>:<span class="hljs-string">&#x27;100vh&#x27;</span>,<br>    <span class="hljs-attr">height</span>:<span class="hljs-number">100</span>,<br>    <span class="hljs-attr">backgroundColor</span>:<span class="hljs-string">&#x27;grey&#x27;</span><br>&#125;    &#125;<br><span class="hljs-keyword">return</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">img</span></span></span><br><span class="hljs-tag"><span class="language-xml">            //<span class="hljs-attr">src标签不能提出</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;image&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            &#123;<span class="hljs-attr">...imgData</span>&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">            /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>)<br></code></pre></td></tr></table></figure><p>自定义组件<code>react的props</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Artcile</span>(<span class="hljs-params"></span>)<br>&#123;<br>    <span class="hljs-keyword">return</span>(<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>111<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>222<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>)<br>&#123;<br>    <span class="hljs-keyword">return</span>(<br>        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Article</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Article</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Article</span>/&gt;</span>                                  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Article</span>/&gt;</span> </span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br><br><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>如果对组件的结构逻辑 样式复用</p><p>内容不复用的话 可以写成</p><p>对组件内容定制</p><p>步骤</p><p>1.对父元素(上面的<code>App</code>)进行请求 请求功能所需要的数据</p><p>2.创建组件</p><p>3.把数据传给组件</p><p>父组件向子组件传普通值</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Detail</span>(<span class="hljs-params"></span>)<br>&#123;<br>    <span class="hljs-keyword">return</span>(<br>        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;content&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>状态:&#123;active?&#x27;显示&#x27;:&#x27;隐藏&#x27;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    )<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Artcile</span>(<span class="hljs-params">&#123;acticleData&#125;</span>)<br><span class="hljs-comment">//采用解构</span><br>&#123;<br>    <span class="hljs-keyword">return</span>(<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Detail</span> &#123;<span class="hljs-attr">...articleData</span>&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">                &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Detail</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>    <span class="hljs-comment">//此时Article没用到content和active</span><br>    <span class="hljs-comment">//但是Detail用到了 可以在Article先不传 直接传给Detail</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>)<br>&#123;<span class="hljs-keyword">const</span> articleData=&#123;<br>    <span class="hljs-attr">title</span>:<span class="hljs-string">&#x27;1&#x27;</span>,<br>    <span class="hljs-attr">detailData</span>:&#123;<br>    <span class="hljs-attr">content</span>:<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-attr">active</span>:<span class="hljs-literal">true</span><br>&#125;<br>&#125;<br>    <span class="hljs-keyword">return</span>(<br>        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Article</span></span></span><br><span class="hljs-tag"><span class="language-xml">            &#123;<span class="hljs-attr">...acticleData</span>&#125;</span></span><br><span class="hljs-tag"><span class="language-xml">            /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Article</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;2&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;2&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">active</span></span></span><br><span class="hljs-tag"><span class="language-xml">            /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Article</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;3&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;3&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">active</span></span></span><br><span class="hljs-tag"><span class="language-xml">            /&gt;</span>                                 </span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br><br><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>父组件向子组件传<code>jsx</code></p><p>插槽 <code>jsx</code>作为<code>props</code>传给子组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">List</span> (&#123;children,title,footer=       <br>                <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>默认底部<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>&#125;)<br><span class="hljs-comment">//此时footer需要一个默认值</span><br>&#123;<br>    <span class="hljs-keyword">return</span>(<br>        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">            &#123;children&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        &#123;footer&#125;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/&gt;</span></span><br>)<br>&#125;<br><span class="hljs-comment">//如果需要在列表加元素</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span> ()<br>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">        //之前是通过props传递 现在通过children</span><br><span class="language-xml">        //自动接受组件开始和接受的内容</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">List</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;列表1&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">footer</span>=<span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                &lt;<span class="hljs-attr">p</span>&gt;</span>这是底部内容1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">            &#125;&gt;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>内容1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>内容2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>内容3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">List</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">List</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;列表2&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">footer</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">p</span>&gt;</span>这是底部内容2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>&#125;&gt;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>内容A<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>内容B<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>内容C<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">List</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">List</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;列表3&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            //<span class="hljs-attr">此时没设置footer会显示默认值</span></span></span><br><span class="hljs-tag"><span class="language-xml">            &gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>内容X<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>内容Y<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>内容Z<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">List</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>子组件向父组件传值</p><p>父组件给子组件一个自定义事件的设置 再通过事件触发后向父组件传递参数来设置</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Detail</span> (&#123;onActive&#125;)&#123;<br>    <span class="hljs-comment">//希望告诉父组件内部状态 在handleClick函数使用的变更 所以在handleClick加入onACtive事件并传入status</span><br>    <span class="hljs-keyword">const</span> [status,setStatus]=<span class="hljs-title function_">useState</span>(<span class="hljs-literal">false</span>)<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleClick</span>(<span class="hljs-params"></span>)<br>    &#123;<br>        <span class="hljs-title function_">setStatus</span>(!status)<br>        <span class="hljs-title function_">onActive</span>(status)<br>        <span class="hljs-comment">//每次状态变更 传递一个新值 传递到function App()</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;handleClick&#125;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> </span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;display;staus?</span></span></span><br><span class="hljs-tag"><span class="language-xml">                    &#x27;<span class="hljs-attr">block</span>&#x27;<span class="hljs-attr">:</span>&#x27;<span class="hljs-attr">none</span>&#x27;&#125;&#125;&gt;</span></span><br><span class="language-xml">                Detail的内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleActive</span>(<span class="hljs-params">status</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(status)<br>    &#125;<br>    <span class="hljs-keyword">return</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">        //如果希望父组件能接受子组件的状态的话需要给子组件设置一个自定义属性(onActive)可以理解为事件 用代码决定在何时触发</span><br><span class="language-xml">        </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Detail</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onActive</span>=<span class="hljs-string">&#123;handleActive&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Detail</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    <br>    )<br>&#125;<br></code></pre></td></tr></table></figure><p>同级组件传值</p><p>在父组件进行中转</p><p>多层级传值</p><p>提供了一个多级属性穿透的hook</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123;useState&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Section</span> (&#123;children&#125;)<br>&#123;<br>    <span class="hljs-comment">//获取上一级level</span><br>    <span class="hljs-keyword">const</span> level=<span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">LevelContext</span>)<br>    <span class="hljs-keyword">return</span> (<br>        <br>        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;section&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">LevelContect.Provider</span> </span></span><br><span class="hljs-tag"><span class="language-xml">                <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">              <span class="hljs-attr">level</span>+<span class="hljs-attr">1</span>      </span></span><br><span class="hljs-tag"><span class="language-xml">                &#125;&gt;</span></span><br><span class="language-xml">             &#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">LevelContect.Provider</span>&gt;</span></span><br><span class="language-xml">           </span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br>    )<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Heading</span>(<span class="hljs-params">&#123;level,children&#125;</span>)<br>&#123;<br>    <span class="hljs-keyword">const</span> level=<span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">LevelContext</span>)<br><span class="hljs-comment">//设置之后此时全为h1(若默认值是1)</span><br><span class="hljs-comment">//但是h1和section嵌套会使h1显示出从大到小的样式</span><br>    <span class="hljs-keyword">switch</span>(level)&#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>&#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>&#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span></span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>            <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>&#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span></span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>            <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>&#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span></span><br>    &#125; <br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">LevelContext</span>=<span class="hljs-title function_">createContext</span>(<span class="hljs-number">0</span>)<br><span class="hljs-comment">//不能直接用 通过useContext</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span> ()&#123;<br>    <span class="hljs-keyword">return</span>(<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Heading</span> &gt;</span>主标题<span class="hljs-tag">&lt;/<span class="hljs-name">Heading</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Heading</span> &gt;</span>副标题<span class="hljs-tag">&lt;/<span class="hljs-name">Heading</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Heading</span> &gt;</span>副标题<span class="hljs-tag">&lt;/<span class="hljs-name">Heading</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Heading</span> &gt;</span>副标题 <span class="hljs-tag">&lt;/<span class="hljs-name">Heading</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Heading</span>&gt;</span>子标<span class="hljs-tag">&lt;/<span class="hljs-name">Heading</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Heading</span>&gt;</span>子标<span class="hljs-tag">&lt;/<span class="hljs-name">Heading</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Heading</span> &gt;</span>子标<span class="hljs-tag">&lt;/<span class="hljs-name">Heading</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>        </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Heading</span> &gt;</span>子子标题<span class="hljs-tag">&lt;/<span class="hljs-name">Heading</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Heading</span>&gt;</span>子子标题<span class="hljs-tag">&lt;/<span class="hljs-name">Heading</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Heading</span> &gt;</span>子子标题<span class="hljs-tag">&lt;/<span class="hljs-name">Heading</span>&gt;</span></span><br><span class="language-xml">              <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Heading</span> &gt;</span>子子子标题<span class="hljs-tag">&lt;/<span class="hljs-name">Heading</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Heading</span> &gt;</span>子子子标题<span class="hljs-tag">&lt;/<span class="hljs-name">Heading</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Heading</span> &gt;</span>子子子标题<span class="hljs-tag">&lt;/<span class="hljs-name">Heading</span>&gt;</span></span><br><span class="language-xml">                  <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>&gt;</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Heading</span> &gt;</span>子子子子标题 <span class="hljs-tag">&lt;/<span class="hljs-name">Heading</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Heading</span> &gt;</span>子子子子标题 <span class="hljs-tag">&lt;/<span class="hljs-name">Heading</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Heading</span> &gt;</span>子子子子标题 <span class="hljs-tag">&lt;/<span class="hljs-name">Heading</span>&gt;</span></span><br><span class="language-xml">                  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml">                  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml">                  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>  </span><br><span class="language-xml">                  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml">                  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml">                  <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></span><br><span class="language-xml">                      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Ps:</code>可能会出现都是<code>h1</code>标签但是大小却不同的情况</p><p><code>section</code> 和<code>h1</code>嵌套时候自然出现的状态</p><p>如何更改<code>useContext</code>能够获取到的level信息</p><p><code>useContext</code>创建的对象<code>LevelContext</code>提供一个<code>Provider</code></p><p>给<code>context</code>提供值的一个方式</p>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Javascript-class类</title>
    <link href="/2023/12/16/Javascript-class%E7%B1%BB/"/>
    <url>/2023/12/16/Javascript-class%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1><code>Javascript</code>-class类</h1><h3 id="类的定义">类的定义</h3><p>有两个组成部分</p><p>类表达式和类声明</p><p>每个类中包含了一个特殊的方法 <code>constructor()</code>，它是类的构造函数，这种方法用于创建和初始化一个由 <code>class</code> 创建的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//类声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,age</span>)<br>    &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//类表达式</span><br><span class="hljs-keyword">const</span> B=<span class="hljs-keyword">class</span>&#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,age</span>)<br>    &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上创造了一个类  叫<code>A</code></p><p>初始化了两个参数 <code>name , age</code></p><h3 id="使用类">使用类</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a1=<span class="hljs-keyword">new</span> A (<span class="hljs-string">&#x27;shanyujia&#x27;</span>,<span class="hljs-number">18</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a1)<br><span class="hljs-comment">// =&gt;&#123; name: &#x27;shanyujia&#x27;, age: 18 &#125;</span><br></code></pre></td></tr></table></figure><p>基于这个类去创造这个类的实例</p><p>基于这个对象生成 结构相同 内部数据不同的对象形式</p><h3 id="自定义方法">自定义方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,age</span>)<br>      &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>      &#125;<br>    <span class="hljs-title function_">introduce</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`我的名字是<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>,我的年龄是<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.age&#125;</span> `</span>)<br>    &#125;<br>&#125;<br>a1.<span class="hljs-title function_">introduce</span>()<br><span class="hljs-comment">// =&gt; 我的名字是shanyujia,我的年龄是18</span><br></code></pre></td></tr></table></figure><h3 id="类的继承">类的继承</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">A</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,age,sex</span>)&#123;<br>        <span class="hljs-comment">//如果希望继承A的属性 写一个super的调用</span><br>        <span class="hljs-comment">//调用父类的constructor 将属性也在B类生成</span><br>    <span class="hljs-variable language_">super</span>(name,age)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">sex</span>=sex<br>    &#125;<br>    <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;你好我是&#x27;</span>+<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> b1=<span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;男&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b1)<br>b1.<span class="hljs-title function_">sayHello</span>()<br>b1.<span class="hljs-title function_">introduce</span>()<br><span class="hljs-comment">/*&#123; name: &#x27;张三&#x27;, age: 20, sex: &#x27;男&#x27; &#125;</span><br><span class="hljs-comment">我的名字是张三,我的年龄是20</span><br><span class="hljs-comment">你好我是张三*/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Javascript 函数</title>
    <link href="/2023/12/09/Javascript-%E5%87%BD%E6%95%B0/"/>
    <url>/2023/12/09/Javascript-%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1>JavaScript 函数</h1><h3 id="1-typeof">1.<code>typeof</code></h3><p>会产生一个字符串的值，内容是给定值的具体类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-number">4.5</span>)<br><span class="hljs-comment">// → number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;x&quot;</span>)<br><span class="hljs-comment">// → string</span><br></code></pre></td></tr></table></figure><h3 id="2-prompt">2.<code>prompt</code></h3><p>包含一函数，个显示一个小对话框，请求用户输入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">prompt</span>(<span class="hljs-string">&quot;Enter passcode&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="3-cosole-log">3.<code>cosole.log</code></h3><p>输出值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> x = <span class="hljs-number">30</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;the value of x is&quot;</span>, x);<br><span class="hljs-comment">// → the value of x is 30</span><br></code></pre></td></tr></table></figure><h3 id="4-Math-max">4.<code>Math.max</code></h3><p>接受任意数量的参数并返回最大</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>));<br><span class="hljs-comment">// → 4</span><br></code></pre></td></tr></table></figure><h3 id="5-Math-min">5.<code>Math.min</code></h3><p>跟Math.max相反</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>) + <span class="hljs-number">100</span>);<br><span class="hljs-comment">// → 102</span><br></code></pre></td></tr></table></figure><h3 id="6-Number-isNaN">6.<code>Number.isNaN</code></h3><p>仅当它给出的参数是<code>NaN</code>时才返回<code>true</code></p><p>当你给它一个不代表有效数字的字符串时</p><p><code>Number</code>函数恰好返回<code>NaN</code></p><h3 id="7-函数定义">7.函数定义</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">square</span>(<span class="hljs-params">x</span>)<br>&#123;<br><span class="hljs-keyword">return</span> x*x;<br>&#125;<br></code></pre></td></tr></table></figure><p>以关键字<code>function</code>起始的表达式创建</p><p>函数有一组参数（例子中只有<code>x</code>）和一个主体</p><p>它包含调用该函数时要执行的语句</p><p><code>return</code> 决定 函数返回值</p><p>没有<code>return</code>的函数 返回<code>undefined</code></p><h3 id="8-箭头函数">8.箭头函数</h3><p><code>=&gt;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">square1</span> = (<span class="hljs-params">x</span>) =&gt; &#123; <span class="hljs-keyword">return</span> x * x; &#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">square2</span> = x =&gt; x * x;<br></code></pre></td></tr></table></figure><p>箭头出现在参数列表之后,然后是函数主体</p><p>表达的意思类似于 这个输入(参数)产生这个结果(主体)</p><h3 id="9-push">9.push</h3><p>将值添加到数组的末尾</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> sequence = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>sequence.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>);<br>sequence.<span class="hljs-title function_">push</span>(<span class="hljs-number">5</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sequence);<br><span class="hljs-comment">// → [1, 2, 3, 4, 5]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sequence.<span class="hljs-title function_">pop</span>());<br><span class="hljs-comment">// → 5</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sequence);<br><span class="hljs-comment">// → [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><h3 id="10-pop"><code>10.pop</code></h3><p>与push相反 删除数组中最后的一个值并将其返回</p><h3 id="11-delete"><code>11.delete</code></h3><p>一元运算符</p><p>当应用于对象属性时，将从对象中删除指定的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> anObject = &#123;<span class="hljs-attr">left</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">right</span>: <span class="hljs-number">2</span>&#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(anObject.<span class="hljs-property">left</span>);<br><span class="hljs-comment">// → 1</span><br><span class="hljs-keyword">delete</span> anObject.<span class="hljs-property">left</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(anObject.<span class="hljs-property">left</span>);<br><span class="hljs-comment">// → undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;left&quot;</span> <span class="hljs-keyword">in</span> anObject);<br><span class="hljs-comment">// → false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;right&quot;</span> <span class="hljs-keyword">in</span> anObject);<br><span class="hljs-comment">// → true</span><br></code></pre></td></tr></table></figure><h3 id="12-in"><code>12.in</code></h3><p>二元运算符  会告诉你该对象是否具有名称为它的属性</p><p>将属性设置为 undefined 和实际删除它的区别在于</p><p>在设置为undefined的时候 对象仍然具有属性 只是没有意义</p><p>删除它时 属性不再存在 <code>in</code> 会返回 <code>false</code></p><h3 id="13-Object-keys">13.<code>Object.keys</code></h3><p>给它一个对象 它返回一个字符串数组 -对象的属性名称</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(&#123;<span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">2</span>&#125;));<br><span class="hljs-comment">// → [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="14-Object-assgin"><code>14.Object.assgin</code></h3><p>可以将一个对象的所有属性复制到另一个对象中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> objectA = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(objectA, &#123;<span class="hljs-attr">b</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">4</span>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objectA);<br><span class="hljs-comment">// → &#123;a: 1, b: 3, c: 4&#125;</span><br></code></pre></td></tr></table></figure><h3 id="15-Math-sqrt"><code>15.Math.sqrt</code></h3><p>平方根函数</p><h3 id="16-unshift"><code>16.unshift</code></h3><p>在数组开头添加元素</p><h3 id="17-shift"><code>17.shift</code></h3><p>在数组的开头删除元素</p><p><code>remember(&quot;groceries&quot;)</code>将任务添加到队列的末尾</p><p><code>getTask()</code>从队列中获取（并删除）第一个项目</p><p><code>rememberUrgently</code>函数也添加任务 .</p><p>但将其添加到队列的前面而不是队列的后面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> todoList = [];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">remember</span>(<span class="hljs-params">task</span>) &#123;<br>  todoList.<span class="hljs-title function_">push</span>(task);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getTask</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> todoList.<span class="hljs-title function_">shift</span>();<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">rememberUrgently</span>(<span class="hljs-params">task</span>) &#123;<br>  todoList.<span class="hljs-title function_">unshift</span>(task);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="18-lastIndexOf"><code>18.lastIndexOf</code></h3><p>跟<code>indexof</code> 类似  <code>indexof</code>从数组第一个元素开始搜索</p><p><code>lastIndexOf</code> 从最后一个元素向前搜索</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>].<span class="hljs-title function_">indexOf</span>(<span class="hljs-number">2</span>));<br><span class="hljs-comment">// → 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>].<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-number">2</span>));<br><span class="hljs-comment">// → 3</span><br></code></pre></td></tr></table></figure><h3 id="19-Math">19.<code>Math</code></h3><p><code>Math.max</code>最大值</p><p><code>Math.min</code>最小值</p><p><code>Math.sqrt</code>平方根</p><p><code>Math.random</code>生成一个随机数 范围在 0（包括）到 1（不包括）之间</p><p><code>Math.PI</code>表示数字<code>π</code></p><p><code>Math.floor</code>向下取整到与当前数字最接近的整数</p><p><code>Math.ceil</code>向上取整</p><p><code>Math.abs</code>取数字的绝对值</p><p><code>Math.round</code>四舍五入</p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>javascript1</title>
    <link href="/2023/11/27/javascript%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2023/11/27/javascript%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="javascript第一章">javascript第一章</h3><h5 id="一元运算符">一元运算符</h5><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-number">4.5</span>)<br> <span class="hljs-comment">//输出 number</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-string">&quot;x&quot;</span>)<br><span class="hljs-comment">//输出 string</span><br></code></pre></td></tr></table></figure><p>typeof生成一个字符串值 得出你给它的值的类型名</p><h5 id="布尔值">布尔值</h5><p>有两个值  <code>true</code> 和 <code>false</code></p><p>生成布尔值的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> (<span class="hljs-number">3</span>&gt;<span class="hljs-number">2</span>)<br><span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> (<span class="hljs-number">3</span>&lt;<span class="hljs-number">2</span>)<br><span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>符号 &gt; 和 &lt; 表示 “大于”和“小于” 二元运算符</p><p>返回的结果是一个布尔值，表示其运算是否为真。</p><p>也可以用这种方法比较字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Aardvark&quot;</span> &lt; <span class="hljs-string">&quot;Zoroaster&quot;</span>)<br><span class="hljs-comment">// → true</span><br></code></pre></td></tr></table></figure><p>在 JavaScript 中，只有一个值不等于其自身，那就是NaN（非数值）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span> (<span class="hljs-title class_">NaN</span> == <span class="hljs-title class_">NaN</span>)<br><span class="hljs-comment">// → false</span><br></code></pre></td></tr></table></figure><p>NaN用于表示非法运算的结果</p><p>逻辑运算符</p><p><code>&amp;&amp;</code> 运算符表示逻辑与，该运算符是二元运算符，只有当赋给它的两个值均为<code>true</code>时其结果才是真</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-literal">false</span>)<br><span class="hljs-comment">// → false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-literal">true</span>)<br><span class="hljs-comment">// → true</span><br></code></pre></td></tr></table></figure><p><code>||</code>运算符表示逻辑或。当两个值中任意一个为<code>true</code>时，结果就为真</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">false</span> || <span class="hljs-literal">true</span>)<br><span class="hljs-comment">// → true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">false</span> || <span class="hljs-literal">false</span>)<br><span class="hljs-comment">// → false</span><br></code></pre></td></tr></table></figure><p>优先级问题</p><p><code>||</code>优先级最低,其次是<code>&amp;&amp;</code>,然后是比较运算符(<code>&gt;,==,&lt;</code>)</p><p>最后是其他运算符</p><p>三元预算符</p><p><code>A?B:C</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">true</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>);<br><span class="hljs-comment">// → 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">false</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>);<br><span class="hljs-comment">// → 2</span><br></code></pre></td></tr></table></figure><p>被叫做条件运算符</p><p>问号左面的值挑选一个值</p><p>它为 <code>true</code> 是 选择中间的值</p><p>它为<code>false</code> 是选择右面的值</p><h5 id="空值">空值</h5><p><code>null</code> <code>undefined</code></p><p>表示不存在有意义的值</p><p>两者差别不大</p>]]></content>
    
    
    <categories>
      
      <category>Javascript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>my new post</title>
    <link href="/2023/11/20/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/"/>
    <url>/2023/11/20/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="ctype-h">ctype.h</h2><h5 id="1-isascii">1.isascii()</h5><p>判断是不是在0-127</p><p>是ASCII 是1</p><p>不是ASCII 是0</p><h5 id="2-isalpha">2.isalpha</h5><p>小写2 大写1 不是字母0</p><h5 id="3-isdigit">3.isdigit</h5><p>是不是十进制</p><p>0-9 返回非0</p><p>不然返回0</p><h5 id="4-isalnum">4.isalnum()</h5><p>是不是字母或者数字</p><p>是返回非0 不是返回0</p><h5 id="5-isblank">5.isblank()</h5><p>是不是空白字符</p><p>是 输出非0</p><p>不是 输出0</p><h5 id="6-isspace">6.isspace()</h5><p>是不是空白字符</p><p>‘ ’ or ‘\t’ or ‘ \r’ or ‘ \n’ or ‘ \v ’or  ‘\f ’</p><h5 id="7-islower">7.islower()</h5><p>是不是小写字母</p><p>是为 非零 不是为0</p><h5 id="8-isupper">8.isupper()</h5><p>是不是大写字母</p><p>是 非零 不是零</p><h5 id="9-toupper">9.toupper()</h5><p>转换为大写字母</p><p>touppper(‘a’)</p><h5 id="10-tolower">10.tolower()</h5><p>转换为小写字母</p><p>tolower(‘A’)</p><h5 id=""></h5>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
